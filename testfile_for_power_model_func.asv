path_spa = "C:\Users\axel_\Documents\MATLAB\windpower-baseload-project\model\data\spa_gri_18-23.grib";
path_cre = "C:\Users\axel_\Documents\MATLAB\windpower-baseload-project\model\data\grece_crete18-23.grib";

%Read data and windspeeds
Wind_Speed_spa = ReadWindData(path_spa);
Wind_Speed_gre = ReadWindData(path_cre);

%%

%Park and turbine characteristics
Rated_Power = 5*10^9; 
Rated_Wind = 11;
Cut_In = 3;
Cut_Out = 25;

%power calc
Sum = true;
power_vec = Power_Calculations(Cut_In,Cut_Out,Rated_Wind,Rated_Power,Wind_Speed_spa,Sum);
power_vec2 = Power_Calculations(Cut_In,Cut_Out,Rated_Wind,Rated_Power,Wind_Speed_gre,Sum);
power_matrix = [power_vec; power_vec2];

%%

%X-vector
X = 1:length(power_vec);

%pre-allocate arrays
n = 2; %number of parks
loc_storage_matrix = zeros(n,length(X));
power_out_matrix = zeros(n,length(X));
big_storage_vec = zeros(1,length(X));
power_diff_vec = zeros(1,n);

%load max and min
cable_power_cap = 4*10^9;
min_power_out = 3*10^9;
loc_storage_cap = 10*10^9; %? It will decrease when adding more parks

%index start 2 to initiate as loop is dependent on i-1

%% Inte klart... OCH DÅLIGT; SE NEDAN

% i - iterate over time series
% j - iterate over number of parks
for i = 2:length(power_vec)
    %iterates over one time index for all parks
    for j = 1:n
        p = power_matrix(j,i);
        if p >= cable_power_cap                      %if power is bigger than the cable's, store the remainder in storage
            loc_storage_matrix(j,i) = loc_storage_matrix(j,i-1) + p - cable_power_cap;
            power_out_matrix(j,i) = cable_power_cap;
            power_diff_vec(j) = 0;                  %store 0 in temp vector
        elseif p < min_power_out                    %if power is lower than min, use storage
            power_diff_vec(j) = min_power_out - p;  %store -diff in temp vector
        else
            power_diff_vec(j) = p - min_power_out; %store +diff in temp vector 
        end
    end

    %här här man gått igenom ett tidssteg för alla parker... skicka
    %överskotts energi till parker, om inte finns någon som vill ha till
    %storage

    balance = sum(power_diff_vec);
    if balance == 0
        %nothing happens as power_out_matrix is already calculated 
    elseif balance > 0  %if there is a surplus in total;
        %three alternatives 
        %1 - set all power_out to min min_power_out and store the rest
        %regionally -  (easy and keeps a steady load but introduces losses
        %and bigger storage)
        power_out_matrix(:,i) = min_power_out;
        big_storage_vec(i) = big_storage_vec(i-1) + balance;

        %2 - set the parks with negative power_diff to min_power_out and
        % calculate the difference between one + and one - til all are
        % good... save the rest in local or regional

        %3 - set the parks with negative power_diff to min_power_out and
        % fil the biggest +power_diff from before with the remainder(but not bigger than originally), then the second biggest... 

        %4 - introduce a distance/efficency matrix, sends to the ones that
        %have shortest distance/best efficency
    else
        %if there are +power_diffs send them to closest parks that are -.
        %When there are no +power_diffs, take from local storage,
        %if local storage empty, take from regional.

    end


    %någon if sats
        %take from local storage
        if loc_storage_matrix(j,i-1) > power_diff_vec(j)
           loc_storage_matrix(j,i) = loc_storage_matrix(j,i-1) - power_diff_vec(j);
           power_out_matrix(j,i) = min_power_out; 
        elseif loc_storage_matrix(j,i-1) < power_diff_vec(j) % if not enough power stored to reach min, empty the storage
            loc_storage_matrix(i) = 0;
            power_out_matrix(i) = loc_storage_matrix(i);
        end
    %här ska all
end


% %remove first zero-value index.
% loc_storage_matrix(1) = [];
% power_out_matrix(1) = [];



%% %Detta är en bättre approach!! Skippar en for loop, toppen!

% Initialize power and storage matrices (T x N)

%X-vector
X = 1:length(power_vec);

%pre-allocate arrays
n = 2; %number of parks
T = length(X); % number of timesteps

power_matrix = [power_vec; power_vec2];    % Power output data for each park over time
loc_storage_matrix = zeros(n,T);
power_out_matrix = zeros(n,T);
big_storage_vec = zeros(1,T);

%load max and min
cable_power_cap = 4*10^9;
min_power_out = 3*10^9;
loc_storage_cap = 10*10^9; %? It will decrease when adding more parks



for t = 1:T
    % Calculate current power balance for each park
    power_diff_vec = power_matrix(:, t) - min_power_out;  % Vector of power differences
    
    % Calculate surplus and deficit values for each park
    surplusValues = max(power_diff_vec, 0);  % Surplus values (positive or zero)
    deficitValues = -min(power_diff_vec, 0); % Deficit values (positive or zero)
    
    % Total surplus and total deficit
    totalSurplus = sum(surplusValues);
    totalDeficit = sum(deficitValues);
    
    % Redistribute power based on the calculated surplus and deficit
    if totalSurplus >= totalDeficit
        % Sufficient surplus to cover deficits
        
        % Update storage for deficit parks (adding the deficit values)
        loc_storage_matrix(:, t+1) = loc_storage_matrix(:, t);
        loc_storage_matrix(:, t+1) = loc_storage_matrix(:, t+1) + deficitValues;
        
        % Reduce storage for surplus parks (distribute equally among surplus parks)
        numSurplusParks = sum(surplusValues > 0);
        loc_storage_matrix(surplusValues > 0, t+1) = loc_storage_matrix(surplusValues > 0, t) - ...
                                                     (totalDeficit / numSurplusParks);
    else
        % Insufficient surplus, distribute proportionally
        
        % Calculate the proportion of each park's deficit that can be covered
        deficitShare = (surplusValues / totalSurplus) .* totalDeficit;
        
        % Update storage for deficit parks proportionally
        loc_storage_matrix(:, t+1) = loc_storage_matrix(:, t);
        loc_storage_matrix(deficitValues > 0, t+1) = loc_storage_matrix(deficitValues > 0, t+1) + deficitShare;
        
        % Surplus parks contribute all their available surplus
        loc_storage_matrix(surplusValues > 0, t+1) = loc_storage_matrix(surplusValues > 0, t) - surplusValues(surplusValues > 0);
    end

end

% Display sample results for a given time step
sampleTimeStep = 10;
disp(['Surplus values at time step ', num2str(sampleTimeStep), ': ', num2str(surplusValues')]);
disp(['Deficit values at time step ', num2str(sampleTimeStep), ': ', num2str(deficitValues')]);